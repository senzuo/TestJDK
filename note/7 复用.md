#  7 复用

复用类: 利用现有类型生成新类型

组合：在新类中产生现有类的对象，该方法复用了现有类代码的功能，而非形式

继承

## 组合语法

初始化引用

- 定义处
- 构造器
- 惰性
- 使用时

## 继承语法

没用显示的继承，那么就是隐式继承 Object 对象

如果超类没有默认构造器，或者导出类想要调用含参数的构造器，必须用 super 显示调用，并且这是在导出类中的第一件事

## 代理

组合和继承的中庸之道

将一个成员对象置于新类中（组合），在新类中暴露了该成员对象的所有方法（继承）

eg 太空船 控制模块

## 组合 & 继承

重载在继承中正常工作 （与C++不同）

@Override 覆盖

## 组合 or 继承

> 判断方法：是否需要从新类向超类向上转型？

is - a

has - a

## protected

## 向上转型

## final

> 两个角度考虑问题 ： 设计 & 效率

### final数据

- 基本数据
- 对象

#### 空白final

必须在构造器中初始化

### final方法

#### 设计

确保方法行为不变，不会被覆盖

#### 效率

后期的 JVM 不需要通过Final提高效率

类中的所有private方法都隐式地指定为final，由于无法访问privat，所以自然就无法覆盖他

编写代码发现是可以正常工作的，但是加上@Override注解就会发现，并不是覆盖

### final类

## 初始化&类加载

- 该类的静态方法（包括构造方法）或者静态域被访问时，JVM 定位 .class 文件
- 加载 class ，执行有关静态初始化的所有动作
- new 类()时， 在堆上分配内存
- 内存空间清零
- 执行定义处初始化
- 执行构造器